/**
 * Unit tests for BehaviorExecutor
 * Critical security component - VM sandbox execution
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { BehaviorExecutor } from './behavior-executor.js'
import { writeFile, mkdir, rm } from 'fs/promises'
import { join } from 'path'
import { tmpdir } from 'os'

describe('BehaviorExecutor', () => {
  let executor: BehaviorExecutor
  let testDir: string
  let blueprintPath: string

  beforeEach(async () => {
    // Create temporary test directory
    testDir = join(tmpdir(), `zbl-test-${Date.now()}`)
    await mkdir(testDir, { recursive: true })
    blueprintPath = join(testDir, 'blueprint.toml')
    await writeFile(blueprintPath, '')

    executor = new BehaviorExecutor(blueprintPath)
  })

  afterEach(async () => {
    // Clean up test directory
    await rm(testDir, { recursive: true, force: true })
  })

  describe('executeRender', () => {
    it('should execute simple render function', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return '<h1>Hello World</h1>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toBe('<h1>Hello World</h1>')
    })

    it('should pass data to behavior function', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return '<h1>' + ctx.data.title + '</h1>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: { title: 'Test Title' }, helpers: {} as any }
      )

      expect(html).toBe('<h1>Test Title</h1>')
    })

    it('should provide helper functions', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          const today = ctx.helpers.today()
          return '<p>Today: ' + today + '</p>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toMatch(/<p>Today: \d{4}-\d{2}-\d{2}<\/p>/)
    })

    it('should handle escapeHtml helper', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          const escaped = ctx.helpers.escapeHtml('<script>alert("xss")</script>')
          return '<div>' + escaped + '</div>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toContain('&lt;script&gt;')
      expect(html).not.toContain('<script>')
    })

    it('should timeout long-running behaviors', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          while(true) {} // Infinite loop
        }
        render
      `)

      await expect(
        executor.executeRender(
          { render: './render.js' },
          { data: {}, helpers: {} as any }
        )
      ).rejects.toThrow()
    })

    it('should block filesystem access', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          const fs = require('fs')
          return fs.readFileSync('/etc/passwd', 'utf8')
        }
        render
      `)

      await expect(
        executor.executeRender(
          { render: './render.js' },
          { data: {}, helpers: {} as any }
        )
      ).rejects.toThrow()
    })

    it('should block process access', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return String(process.env.HOME)
        }
        render
      `)

      await expect(
        executor.executeRender(
          { render: './render.js' },
          { data: {}, helpers: {} as any }
        )
      ).rejects.toThrow()
    })

    it('should allow safe built-ins', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          const data = JSON.stringify({ test: 'value' })
          const parsed = JSON.parse(data)
          const rounded = Math.round(3.7)
          const str = String(rounded)
          return '<p>' + parsed.test + ' ' + str + '</p>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toBe('<p>value 4</p>')
    })

    it('should cache behavior files', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return '<h1>Cached</h1>'
        }
        render
      `)

      // First execution
      await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      // Second execution should use cache
      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toBe('<h1>Cached</h1>')
    })

    it('should clear cache', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return '<h1>Original</h1>'
        }
        render
      `)

      await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      executor.clearCache()

      // Update file
      await writeFile(behaviorPath, `
        function render(ctx) {
          return '<h1>Updated</h1>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toBe('<h1>Updated</h1>')
    })

    it('should handle array data iteration', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          const items = ctx.data.items || []
          return '<ul>' + items.map(item => '<li>' + item + '</li>').join('') + '</ul>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: { items: ['Apple', 'Banana', 'Cherry'] }, helpers: {} as any }
      )

      expect(html).toBe('<ul><li>Apple</li><li>Banana</li><li>Cherry</li></ul>')
    })

    it('should handle params', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return '<h1>User: ' + ctx.params.userId + '</h1>'
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any, params: { userId: '123' } }
      )

      expect(html).toBe('<h1>User: 123</h1>')
    })

    it('should return string for non-function result', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        '<h1>Static HTML</h1>'
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toBe('<h1>Static HTML</h1>')
    })

    it('should throw on missing render file', async () => {
      await expect(
        executor.executeRender(
          { render: './nonexistent.js' },
          { data: {}, helpers: {} as any }
        )
      ).rejects.toThrow(/Failed to load behavior file/)
    })

    it('should throw on missing render property', async () => {
      await expect(
        executor.executeRender(
          {},
          { data: {}, helpers: {} as any }
        )
      ).rejects.toThrow('No render behavior defined')
    })
  })

  describe('executeHandler', () => {
    it('should execute custom handler', async () => {
      const behaviorPath = join(testDir, 'handler.js')
      await writeFile(behaviorPath, `
        function handle(ctx) {
          return { success: true, message: 'Handled' }
        }
        handle
      `)

      const result = await executor.executeHandler(
        { on_custom: './handler.js' },
        'on_custom',
        { data: {}, helpers: {} as any }
      )

      expect(result).toEqual({ success: true, message: 'Handled' })
    })

    it('should throw on missing handler', async () => {
      await expect(
        executor.executeHandler(
          {},
          'on_missing',
          { data: {}, helpers: {} as any }
        )
      ).rejects.toThrow(/No handler 'on_missing' defined/)
    })
  })

  describe('helpers', () => {
    it('should format dates correctly', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return ctx.helpers.formatDate('2025-10-10')
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toMatch(/Oct/)
      expect(html).toMatch(/10/)
      expect(html).toMatch(/2025/)
    })

    it('should format date-times correctly', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return ctx.helpers.formatDateTime('2025-10-10T15:30:00Z')
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toMatch(/Oct/)
      expect(html).toMatch(/10/)
    })

    it('should return now timestamp', async () => {
      const behaviorPath = join(testDir, 'render.js')
      await writeFile(behaviorPath, `
        function render(ctx) {
          return ctx.helpers.now()
        }
        render
      `)

      const html = await executor.executeRender(
        { render: './render.js' },
        { data: {}, helpers: {} as any }
      )

      expect(html).toMatch(/^\d{4}-\d{2}-\d{2}T/)
    })
  })
})
