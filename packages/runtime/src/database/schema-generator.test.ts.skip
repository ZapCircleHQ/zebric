/**
 * Unit tests for SchemaGenerator
 * Validates schema generation from Blueprint definitions
 */

import { describe, it, expect } from 'vitest'
import { SchemaGenerator } from './schema-generator.js'
import type { Blueprint, Entity } from '../types/blueprint.js'

describe('SchemaGenerator', () => {
  describe('generate', () => {
    it('should generate schema from blueprint', () => {
      const blueprint: Blueprint = {
        version: '0.1.0',
        project: {
          name: 'Test',
          version: '1.0.0',
          runtime: { min_version: '0.1.0' }
        },
        entities: [
          {
            name: 'Post',
            fields: [
              { name: 'id', type: 'ULID', primary_key: true },
              { name: 'title', type: 'Text', required: true },
              { name: 'content', type: 'LongText' }
            ]
          }
        ],
        pages: []
      }

      const generator = new SchemaGenerator('sqlite')
      const schema = generator.generate(blueprint)

      expect(schema.tables).toBeDefined()
      expect(schema.tables.Post).toBeDefined()
      expect(schema.indexes).toBeDefined()
      expect(schema.relations).toBeDefined()
    })

    it('should skip User entity when auth is enabled', () => {
      const blueprint: Blueprint = {
        version: '0.1.0',
        project: {
          name: 'Test',
          version: '1.0.0',
          runtime: { min_version: '0.1.0' }
        },
        entities: [
          {
            name: 'User',
            fields: [
              { name: 'id', type: 'ULID', primary_key: true },
              { name: 'email', type: 'Email', required: true }
            ]
          },
          {
            name: 'Post',
            fields: [
              { name: 'id', type: 'ULID', primary_key: true },
              { name: 'title', type: 'Text' }
            ]
          }
        ],
        auth: {
          providers: ['email']
        },
        pages: []
      }

      const generator = new SchemaGenerator('sqlite')
      const schema = generator.generate(blueprint)

      expect(schema.tables.User).toBeUndefined()
      expect(schema.tables.Post).toBeDefined()
    })

    it('should include User entity when auth is not enabled', () => {
      const blueprint: Blueprint = {
        version: '0.1.0',
        project: {
          name: 'Test',
          version: '1.0.0',
          runtime: { min_version: '0.1.0' }
        },
        entities: [
          {
            name: 'User',
            fields: [
              { name: 'id', type: 'ULID', primary_key: true },
              { name: 'name', type: 'Text' }
            ]
          }
        ],
        pages: []
      }

      const generator = new SchemaGenerator('sqlite')
      const schema = generator.generate(blueprint)

      expect(schema.tables.User).toBeDefined()
    })
  })

  describe('field types', () => {
    it('should handle Text field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'name', type: 'Text' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('name TEXT')
    })

    it('should handle Integer field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'count', type: 'Integer' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('count INTEGER')
    })

    it('should handle Float field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'price', type: 'Float' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('price REAL')
    })

    it('should handle Boolean field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'active', type: 'Boolean' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('active INTEGER')
    })

    it('should handle DateTime field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'createdAt', type: 'DateTime' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('created_at INTEGER')
    })

    it('should handle Date field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'birthdate', type: 'Date' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('birthdate TEXT')
    })

    it('should handle JSON field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'metadata', type: 'JSON' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('metadata TEXT')
    })

    it('should handle Enum field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'status', type: 'Enum', values: ['active', 'inactive'] }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('status TEXT')
    })

    it('should handle Email field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'email', type: 'Email' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('email TEXT')
    })

    it('should handle Ref field', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'userId', type: 'Ref', ref: 'User.id' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('user_id TEXT')
    })
  })

  describe('field modifiers', () => {
    it('should mark primary key', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('id TEXT PRIMARY KEY')
    })

    it('should mark required fields as NOT NULL', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'name', type: 'Text', required: true }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('name TEXT NOT NULL')
    })

    it('should mark unique fields', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'email', type: 'Email', unique: true }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('email TEXT UNIQUE')
    })

    it('should handle default values', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'active', type: 'Boolean', default: true }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('active INTEGER DEFAULT 1')
    })

    it('should handle default "now" for DateTime', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'createdAt', type: 'DateTime', default: 'now' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('DEFAULT CURRENT_TIMESTAMP')
    })
  })

  describe('indexes', () => {
    it('should create indexes', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'email', type: 'Email' }
        ],
        indexes: [
          { fields: ['email'], unique: false }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements.length).toBeGreaterThan(1)
      expect(statements[1]).toContain('CREATE INDEX')
      expect(statements[1]).toContain('email')
    })

    it('should create unique indexes', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'slug', type: 'Text' }
        ],
        indexes: [
          { fields: ['slug'], unique: true }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[1]).toContain('CREATE UNIQUE INDEX')
      expect(statements[1]).toContain('slug')
    })

    it('should create composite indexes', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'userId', type: 'Ref', ref: 'User.id' },
          { name: 'status', type: 'Text' }
        ],
        indexes: [
          { fields: ['userId', 'status'], unique: false }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[1]).toContain('user_id, status')
    })

    it('should create unique index for unique fields', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'email', type: 'Email', unique: true }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      // Should create unique index for email
      const hasUniqueIndex = statements.some(stmt =>
        stmt.includes('UNIQUE INDEX') && stmt.includes('email')
      )
      expect(hasUniqueIndex).toBe(true)
    })
  })

  describe('camelCase to snake_case', () => {
    it('should convert entity names', () => {
      const entity: Entity = {
        name: 'BlogPost',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('blog_post')
    })

    it('should convert field names', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'createdAt', type: 'DateTime' },
          { name: 'updatedAt', type: 'DateTime' },
          { name: 'firstName', type: 'Text' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('created_at')
      expect(statements[0]).toContain('updated_at')
      expect(statements[0]).toContain('first_name')
    })
  })

  describe('generateInitialSchemaStatements', () => {
    it('should generate complete schema', () => {
      const blueprint: Blueprint = {
        version: '0.1.0',
        project: {
          name: 'Test',
          version: '1.0.0',
          runtime: { min_version: '0.1.0' }
        },
        entities: [
          {
            name: 'Post',
            fields: [
              { name: 'id', type: 'ULID', primary_key: true },
              { name: 'title', type: 'Text', required: true }
            ]
          }
        ],
        pages: []
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateInitialSchemaStatements(blueprint)

      expect(statements).toHaveLength(1)
      expect(statements[0]).toContain('CREATE TABLE')
      expect(statements[0]).toContain('post')
    })

    it('should include Better Auth schema when auth is enabled', () => {
      const blueprint: Blueprint = {
        version: '0.1.0',
        project: {
          name: 'Test',
          version: '1.0.0',
          runtime: { min_version: '0.1.0' }
        },
        entities: [],
        auth: {
          providers: ['email']
        },
        pages: []
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateInitialSchemaStatements(blueprint)

      expect(statements.length).toBeGreaterThan(0)
      expect(statements.some(s => s.includes('CREATE TABLE IF NOT EXISTS user'))).toBe(true)
      expect(statements.some(s => s.includes('CREATE TABLE IF NOT EXISTS session'))).toBe(true)
      expect(statements.some(s => s.includes('CREATE TABLE IF NOT EXISTS account'))).toBe(true)
      expect(statements.some(s => s.includes('CREATE TABLE IF NOT EXISTS verification'))).toBe(true)
    })

    it('should not include Better Auth schema when auth is disabled', () => {
      const blueprint: Blueprint = {
        version: '0.1.0',
        project: {
          name: 'Test',
          version: '1.0.0',
          runtime: { min_version: '0.1.0' }
        },
        entities: [],
        pages: []
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateInitialSchemaStatements(blueprint)

      expect(statements.some(s => s.includes('CREATE TABLE IF NOT EXISTS user'))).toBe(false)
      expect(statements.some(s => s.includes('CREATE TABLE IF NOT EXISTS session'))).toBe(false)
    })
  })

  describe('generateAddColumnStatements', () => {
    it('should generate ALTER TABLE statement', () => {
      const entity: Entity = {
        name: 'Post',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true }
        ]
      }

      const field = { name: 'tags', type: 'JSON' as const }

      const generator = new SchemaGenerator('sqlite')
      const result = generator.generateAddColumnStatements(entity, field)

      expect(result.statement).toContain('ALTER TABLE post')
      expect(result.statement).toContain('ADD COLUMN')
      expect(result.statement).toContain('tags TEXT')
    })

    it('should include unique index in post statements', () => {
      const entity: Entity = {
        name: 'Post',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true }
        ]
      }

      const field = { name: 'slug', type: 'Text' as const, unique: true }

      const generator = new SchemaGenerator('sqlite')
      const result = generator.generateAddColumnStatements(entity, field)

      expect(result.postStatements).toHaveLength(1)
      expect(result.postStatements[0]).toContain('CREATE UNIQUE INDEX')
      expect(result.postStatements[0]).toContain('slug')
    })
  })

  describe('getTableName', () => {
    it('should return snake_case table name', () => {
      const generator = new SchemaGenerator('sqlite')

      expect(generator.getTableName('User')).toBe('user')
      expect(generator.getTableName('BlogPost')).toBe('blog_post')
      expect(generator.getTableName('UserComment')).toBe('user_comment')
    })
  })

  describe('database types', () => {
    it('should handle SQLite types', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'ULID', primary_key: true },
          { name: 'count', type: 'Integer' }
        ]
      }

      const generator = new SchemaGenerator('sqlite')
      const statements = generator.generateCreateStatementsForEntity(entity)

      expect(statements[0]).toContain('INTEGER')
    })

    it('should handle PostgreSQL types', () => {
      const entity: Entity = {
        name: 'Test',
        fields: [
          { name: 'id', type: 'UUID', primary_key: true },
          { name: 'active', type: 'Boolean' }
        ]
      }

      const generator = new SchemaGenerator('postgres')
      const schema = generator.generate({
        version: '0.1.0',
        project: { name: 'Test', version: '1.0.0', runtime: { min_version: '0.1.0' } },
        entities: [entity],
        pages: []
      })

      expect(schema.tables.Test).toBeDefined()
    })
  })
})
